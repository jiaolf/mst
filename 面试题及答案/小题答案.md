1. ### activity的四种启动模式及应用场景

    - standard：标准模式，每次都会在活动栈中生成一个新的`Activity`实例
    - singleTop：栈顶复用，如果`Activity`实例已经存在栈顶，那么就不会在活动栈中创建新的实例。比较常见的场景就是给通知跳转的`Activity`
    - singleTask：栈内复用，如果`Activity`实例在当前栈中已经存在，就会将当前`Activity`实例上面的其他`Activity`实例都移除栈。常见于跳转到主界面。
    - singleInstance: 单例模式，创建一个新的任务栈，这个活动实例独自处在这个活动栈中。在一个新栈中创建该Activity实例，并让多个应用共享改栈中的该Activity实例。（系统应用多一点，App一般用的比较少）如：语言通话的页面，webview的页面。

2. ### activity的onSaveInstanceState和onRestoreInstanceState分别什么时候调用？

      **onSaveInstanceState的调用时机：**
   
   1. 按下HOME键时
   
   1. 从最近应用中选择运行其他的程序时
   
   2. 按下电源键时
   
   3. 启动其他Activity时
   
   4. 横竖屏切换时
   
      > 注意几点（来自官方的解释）：
   
      - 该方法是在Activity被杀之前调用以便之后恢复状态
      - 举例：如果activity B启用后位于activity A的之前，当activity A因为系统回收资源的问题要被杀掉，A通过onSaveInstanceState将有机会保存其用户界面状态，使得将来用户返回到activity A时能通过onCreate(Bundle)或者onRestoreInstanceState(Bundle)恢复界面的状态。
      - 要区分开onPause（Activity切到后台或者销毁时必定调用）和onStop（Activity销毁时必定调用）举例：会调用onPause()和onStop()，但不调用onSaveInstanceState的例子是当用户从Activity B返回到Activity A时：没有必要调用B的onSaveInstanceState(Bundle)，因为B实例永远不会被恢复，因此系统会避免调用它。调用onPause()但不调用onSaveInstanceState的例子是当Activity B启动并处在activity A的前端：如果在B的整个生命周期里A的用户界面状态都没有被破坏的话，系统是不会调用Activity A的onSaveInstanceState(Bundle)的。
      - onSaveInstanceState的调用时机不能保证是在onPause之前还是之后，但是一定会在onStop()前被触发
      
      
      
      **onRestoreInstanceState的调用时机：**
      1）onSaveInstanceState和onRestoreInstanceState不一定是成对调用的，在 Activity 被系统销毁之后 恢复 Activity 时被调用, 只有销毁了之后重建的时候才调用。
      2）另外，onRestoreInstanceState的bundle参数也会传递到onCreate方法中，你也可以选择在onCreate方法中做数据还原。
      3）This method is called after onStart when the activity is being re-initialized from a previously saved state, given here in savedInstanceState.（这个方法在onStart之后调用，当Activity从先前保存的状态重新初始化时）

      
      
      **onNewIntent的调用时机：**

      ①如果ActivityA已经启动过,处于当前应用的Activity堆栈中；当ActivityA的LaunchMode为  SingleTop时，如果ActivityA在栈顶，且现在要再启动ActivityA，这时会调用onNewIntent方法。
      ②当ActivityA的LaunchMode为SingleInstance、SingleTask时，如果ActivityA已经在堆栈中，那么此时会调用onNewIntent方法。
      ③当ActivityA的LaunchMode为Standard时，由于每次启动ActivityA都是启动新的实例，和原来启动的没关系，所以不会调用原来ActivityA的onNewIntent方法，仍然调用的是onCreate方法。
      
      > 当Activity启动模式为**singleTask或者singleInstance或者singleTop复用**的时候，通过Intent启到一个Activity，   如果系统**已经存在**一个实例，系统就会将请求发送到这个实例上，但这个时候，系统就不会再调用通常情况下我们处理请求数据的onCreate方法，而是调用onNewIntent方法。

3. ### 什么是Service？IntentService？
