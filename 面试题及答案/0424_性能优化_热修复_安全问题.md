## Android中的性能优化问题

- ANR的问题及解决/响应速度优化
- 内存泄漏
- 布局优化
- 绘制优化
- bitmap优化，RecyclerView优化
- 线程优化
- apk瘦身

1. #### ANR的问题及解决。（什么是ANR，为什么会出现ANR，如何解决，有哪些检测工具？）

   卡顿检测：

2. #### 内存泄漏。（什么情况下会引起内存泄漏？检测工具？检测框架？）

   检测工具：

   - **MAT-eclipse**：“Memory Analyzer Tool”，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的JAVA heap分析工具，它可以帮助我们查找[内存泄漏](https://so.csdn.net/so/search?q=内存泄漏&spm=1001.2101.3001.7020)和减少内存消耗。
   - **Leakcanary**：一款开源的自动检测内存泄漏的工具。
   - **AndroidStudio Profiler**：Android Studio 3.0 采用全新的 “Android Profiler” 窗口取代 Android Monitor 工具。 这些全新的分析工具能够提供关于应用 CPU、内存和网络 Activity 的实时数据。 您可以执行基于样本的函数跟踪来记录代码执行时间、采集堆转储数据、查看内存分配，以及查看网络传输文件的详情。

3. #### 布局优化

   

4. #### 绘制优化

   

5. #### Bitmap优化

   

6. #### 线程优化

   

7. #### apk安装包大小的优化、瘦身



## 热修复

1. 热修复的解决方案有哪些？原理都是什么？

虽然市面上热修复框架很多，但热修复的核心技术主要是三种：资源修复、代码修复和动态链接库修复。

当下主流的热修复框架：

- 腾讯：Tinker
- 阿里：AndFix
- 美团：Robust

![](https://upload-images.jianshu.io/upload_images/306368-899029b08e3c3602.png)

### 资源修复

很多热修复框架的资源修复实现都参考了AndroidStudio中的Instant Run的资源修复的原理。

### 代码修复

代码修复主要有三种方案，分别是**底层替换方法**，**类加载方案**和**Instant Run**方案

### 动态链接库（.so）修复

热修复框架的动态链接库（.so）修复，主要是更新so文件，换句话说就是重新加载so文件。因此so修复的基本原理就是重新加载so文件。加载so文件主要用到了System类中的load方法和loadLibrary方法

2. 你在项目中都用过哪些热修复方案？

   回答：自己在之前的项目中用的是Tinker，那就要具体说一下这个的实现原理，如何使用，注意事项，都遇到了哪些问题等等

## 安全问题

1. 防止反编译，apk加固的原理是什么？

## Android中加壳的原理：

在加固的过程中需要三个对象：
 1、需要加密的Apk(源Apk)
 2、壳程序Apk(负责解密Apk工作)
 3、加密工具(将源Apk进行加密和壳Dex合并成新的Dex)

主要步骤：
 拿到需要加密的Apk和自己的壳程序Apk，然后用加密算法对源Apk进行加密在将壳Apk进行合并得到新的Dex文件，最后替换壳程序中的dex文件即可。

得到新的Apk,那么这个新的Apk我们也叫作脱壳程序Apk，已经不是一个完整意义上的Apk程序了，他的主要工作是：负责解密源Apk.然后加载Apk,让其正常运行起来。

链接：https://www.jianshu.com/p/e6f16561b373



目前市场主流的APP加固公司有三家，分别是：梆梆加固，360和爱加密。他们的大致流程如下：

1. 首先，去对应网站注册帐号；
2. 然后，上传已经签名过的app到网站，等待加固完成；
3. 最后，加固完成后，下载加固好的apk文件，注意，由于对apk加固会更改apk文件，因此下载下来后，还需要对apk进行重新签名，每个网站都提供了自己的签名工具。

 https://zhuanlan.zhihu.com/p/547672488

---



### 网络通信安全的问题（使用Https + token身份认证 + 数字签名 + 加密算法）

#### 1. 防非法调用——身份认证

身份认证指只有经过合法授权的用户才能调用我们的接口，这里我们采用的是Token验证机制。

```
1. 用户首先需要输入账号密码进行登录；
2. APP带上用户输入的账号密码请求服务端登录接口；
3. 服务端校验账号密码，校验成功返回一个唯一Token作为用户身份凭证；
4. APP将Token缓存，同时登录成功；
5. 用户使用APP浏览数据，APP每次向服务端请求数据时须同时带上缓存的Token；
6. 服务端收到请求，首先会校验Token的合法性，校验成功正常返回数据，校验失败直接返回错误；
```



#### 2. 防抓包——数据加密

加密算法大体上可分为**对称加密**、**非对称加密**和**散列算法**等几种方式

- 对称加密：常见的对称加密算法有DES、3DES、AES、IDEA等。**安全的保存和传递密钥**是使用对称加密最需要关注的问题**。**
- 非对称加密指的是加密过程和解密过程使用不同的密钥，非对称加密算法需要一对密钥（公钥和私钥），公钥用来加密数据、私钥用来解密数据。



#### 3. 防重放攻击——时间戳+随机字符串

数据加密之后再进行通信虽然抓包之后看不到明文数据了，但是这并不能阻止不怀好意之人发起重放攻击。

拦截到请求之后只需再原样发送该请求到服务端就可以发起重放攻击，如果接口内有一些查库之类的比较耗性能的逻辑，那么在短时间内发起大量重放攻击的话将会直接导致服务端崩溃。

**时间戳** 我们在发送的数据里加入当前的时间戳，服务端在收到请求数据后首先取出时间戳与服务器当前时间进行比较，如果两者相差超过一定时间（比如5分钟），那么我们就认为本次请求超时，直接拒绝执行或返回错误就可以。

**随机字符串** 我们在发送的数据中加入一个随机生成的字符串，服务端在收到请求数据后首先在缓存中查找该字符串，如果在缓存中找到则认为这是一次重复请求直接拒绝处理，否则将该字符串加入缓存并继续执行正确逻辑。



#### 4. 防篡改——签名机制

为了防重放攻击，我们在数据中加入了时间戳与随机字符串，但是别人在拦截到我们的请求之后也可以对时间戳和随机字符串进行篡改，面对这种情况服务端要怎么分辨呢？

为了防止数据在传输过程中被篡改，我们引入数字签名机制。

**信息摘要算法** 信息摘要算法（或者叫散列算法）是一种不可逆算法，任意长度的明文数据经过信息摘要算法计算后都可以得出一个固定长度的值（签名）。常见的信息摘要算法有MD5、SHA-1、SHA-256等。

![img](https://imgconvert.csdnimg.cn/aHR0cDovL3AxLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlL2EzMWU4MTRhN2VjNTQ2NzRhNzhkMzI1NzFjYjBmMWFk?x-oss-process=image/format,png)

（1）将数据密文、时间戳、随机字符串以及私密的加盐值一起进行信息摘要算法计算得到签名值；
（2）APP将数据密文、时间戳、随机字符串以及签名值一起发往服务端；
（3）服务端收到数据后对数据密文、时间戳、随机字符串以及加盐值一起进行同样的信息摘要算法计算，将计算出的签名与数据中签名进行对比，签名一致证明没有没有被篡改；

为什么进行信息摘要计算要“加盐”？

举个例子就明白了，比如说123经过MD5计算后的签名值是abc，那么就会产生123->abc这样的对应关系，看到签名值abc我就能反查到原值为123。如果有人收集并保存了足够多的这种对应关系，那么就有可能从签名值反推出原值。

这个时候加盐操作就派上了用场，首先我们生成一个加盐值qwe，这个加盐值qwe并不会在网络传输，只有通信双方自己知道。

我们不直接计算123的签名值，我们将加盐值附加到123的后面得到123qwe，接着我们对123qwe进行MD5计算得到一个不一样的签名值def。

所以说即使原值一样，但只要加盐值不同那么最后得到签名值就不一样，这样也就无法从签名值反推出原值了。



#### 完整的Java解决方案

准备工作：APP与服务端各自生成一对RSA密钥对（公钥和私钥），公钥给到对方、私钥各自私密保存；

APP发送加密数据流程

1、生成一个随机的AES算法密钥；

2、使用服务端的RSA公钥对AES密钥明文进行加密得到AES密钥密文；

3、对参数明文进行AES加密得到参数密文；

4、生成当前请求时间的时间戳；

5、为该次请求生成一个随机字符串；

6、将参数密文、时间戳、随机字符串和AES密钥密文进行MD5计算得到md5值；

7、使用APP自己的RSA私钥对md5值进行签名得到签名值；

8、将参数密文、时间戳、随机字符串、AES密钥密文和签名值一起发送到服务端；

服务端解密数据流程

1、校验时间戳与服务器当前时间的差值是否在合理的区间，超过则认为该次请求超时；

2、校验随机字符串是否已经在缓存中，如果已经在缓存中说明该次请求为重复请求，否则将该字符串加入缓存；

3、从收到的数据中取出参数密文、时间戳、随机字符串和AES密钥密文进行MD5计算得到md5值；

4、使用APP的RSA公钥对计算得到的md5值和请求数据中的签名值进行验证，签名验证通过则说明请求数据没有被篡改；

5、服务端使用自己的RSA私钥解密AES密钥密文得到AES密钥明文；

6、使用AES密钥明文对参数密文进行AES解密操作得到参数明文；

7、拿到参数明文之后进行正常的业务处理逻辑；

8、服务端数据需要经过同样的加密操作之后才能返回给APP；

##### 总结

APP与服务端肯定是要使用HTTPS协议进行通信的，再搭配上RAS+AES混合加密算法以及数字签名机制，相信这套方案在绝大部分情况下是可以保证通信及数据安全的。

当然了，不排除APP有被人破解的可能，这种情况下任何加密机制都是白搭。但是不能说我们的加密机制就没用了，我们只需要将破解我们APP的成本提高到一定程度就可以了。

这个道理其实就跟门锁一样，市面上绝大部分门锁只要有时间都可以被开锁的人打开，那你能说门锁就没有存在的意义了吗？

原文链接：https://blog.csdn.net/kevinxxw/article/details/105603571